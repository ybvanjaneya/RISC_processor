$date
	Wed Oct 18 15:46:05 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module tb_top $end
$var wire 32 ! out [31:0] $end
$var reg 1 " clk $end
$var reg 32 # din [31:0] $end
$var reg 1 $ load $end
$var reg 4 % op [3:0] $end
$var reg 4 & rd [3:0] $end
$var reg 4 ' rs1 [3:0] $end
$var reg 4 ( rs2 [3:0] $end
$scope module dut $end
$var wire 1 " clk $end
$var wire 32 ) din [31:0] $end
$var wire 1 $ load $end
$var wire 4 * op [3:0] $end
$var wire 4 + rd [3:0] $end
$var wire 4 , rs1 [3:0] $end
$var wire 4 - rs2 [3:0] $end
$var wire 1 . zeroFlag $end
$var wire 32 / res [31:0] $end
$var wire 32 0 rdata2 [31:0] $end
$var wire 32 1 rdata1 [31:0] $end
$var wire 32 2 out [31:0] $end
$var wire 1 3 carryFlag $end
$var reg 32 4 A [31:0] $end
$var reg 32 5 B [31:0] $end
$var reg 1 6 alu_en $end
$var reg 1 7 r1 $end
$var reg 1 8 r2 $end
$var reg 1 9 s $end
$var reg 32 : wdata [31:0] $end
$var reg 1 ; wen $end
$scope module inst1 $end
$var wire 1 " clk $end
$var wire 32 < out [31:0] $end
$var wire 1 7 r1 $end
$var wire 1 8 r2 $end
$var wire 4 = rad1 [3:0] $end
$var wire 4 > rad2 [3:0] $end
$var wire 4 ? wad [3:0] $end
$var wire 32 @ wdata [31:0] $end
$var wire 1 ; wen $end
$var wire 32 A rdata2 [31:0] $end
$var wire 32 B rdata1 [31:0] $end
$upscope $end
$scope module inst2 $end
$var wire 4 C aluOp [3:0] $end
$var wire 1 6 enable $end
$var wire 32 D operandA [31:0] $end
$var wire 32 E operandB [31:0] $end
$var wire 1 . zeroFlag $end
$var wire 32 F res [31:0] $end
$var wire 1 3 carryFlag $end
$var parameter 4 G ADD_OP $end
$var parameter 4 H AND_OP $end
$var parameter 4 I NOT_OP $end
$var parameter 4 J OR_OP $end
$var parameter 4 K SLA_OP $end
$var parameter 4 L SRA_OP $end
$var parameter 4 M SRL_OP $end
$var parameter 4 N SUB_OP $end
$var parameter 4 O XOR_OP $end
$var reg 32 P result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
